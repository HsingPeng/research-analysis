#《Android系统UI性能测试方法的研究》阅读报告

## 1. 论文的主要内容
针对 Android 系统 UI 性能测试方法进行研究,提出了使用自动化脚本获取应用启动日志的方式来测试 UI 的启动耗时,并且在流畅度测试方面,通过 MonkeyRunner 工具录制脚本实现自动滑动UI,采集 FPS 值的功能。
## 2. 论文观点及我的思考
对用户体验效果的测试在UI测试中就是UI性能测试，与我所研究的对交互异常的检测一致。UI 性能较差除了与设备本身的硬件配置、使用的网络环境有关外,还受到应用本身的影响。应用本身的影响是该论文研究的重点，也是我交互异常检测和分析的重点。应用本身的影响主要包括以下三个方面：
### 2.1 App的启动时间过长——对应于StartMenu启动时间过长的研究
#### 论文观点：
App的启动时间过长会出现长时间页面加载、闪屏、黑屏等情况。一个 UI 的启动时间分为两大类:一类是响应时延,即打开窗口的时间,在 web 页面就从浏览器发请求到 html 开始渲染的时间;另一类是数据加载时间,包括加载本地数据和网络数据,本地数据可能存在加解密和解压缩等过程。无论是客户端还是在 web 页面,在测试新需求时,应该关注是否新增窗口、数据容量最大多少、数据加载是同步还是异步等。

因此,一个 UI 启动速度慢由两个原因引起。第一个原因是外界原因导致,例如移动网络的慢。第二个原因,是应用自身原因导致 UI 启动缓慢。比如,一个 UI 在启动的过程中进行大量的写文件、重复读文件、解压缩包等操作时,都会影响到 UI的启动速度。

#### 我的思考：
鉴于对StartMenu源码的理解和与工程师的交流，在StartMenu启动过程中，会打开新的窗口，但是不存在浏览器请求，所以启动速度慢主要由于自身原因导致，可能的主要原因是对数据库信息的读取导致，读取数据容量有多大，数据加载是同步还是异步的需要进一步研究。

延伸一下，对于有网络请求的activity，AppInsight可以分析由于网络请求产生的异步调用所花费的时间，从而判断是否因网速导致启动时间过长。
#### 论文观点：
UI 启动是一个 Activity 的跳转原理。在一个 Activity 的界面跳到另外一个Activity 时,需要一个触发。最简单的例子是用户在 ActivityA 界面上点击了某一按钮,启动 ActivityB,当 ActivityB 界面上没有控件加载时,用户的感知时延跟测试的数据基本一样 。从 ActivityA 跳 到 ActivityB , 首先在ActivityA调用一个startActivity(intent)方法,接着通过onCreate()创建 ActivityB,但一直调用到onResume(),ActivityB 界面不会立即呈现,只有将 View 添加到 Window 之后,ActivityB 所在的界面才显示出来。
#### 我的思考：
首先更正一个之前理解的错误，之前获取Activity显示时间时在onResume()打LOG是错误的。“调用到onResume(),ActivityB 界面不会立即呈现,只有将 View 添加到 Window 之后,ActivityB 所在的界面才显示出来”。

“当 ActivityB 界面上没有控件加载时,用户的感知时延跟测试的数据基本一样”是什么意思？控件加载是读取数据的意思吗？StartMenu会加载应用信息，这对测试有什么影响？难道会测试不准确？

#### 论文观点：
测试一个 UI 的启动时延是指计算一个 UI 应用从第一次安装后,点击进入应用,待界面显示出来所花费的时间。也可以直接对一个 UI 应用清除数据后,点击启动,测试耗时。

#### 我的思考：
StartMenu启动延迟现象在重启计算机后比较明显，之后再点击并不会那么明显，这两种情况还需要实验来做一下验证。重启计算机类似于清楚数据后重启。我所研究的是哪种情况？

#### 论文观点：
**传统的测试方法：**

**秒表法计时**：传统秒表测试时延的方法是指测试人员一只手拿着一个秒表,一只手拿着手机,然后点击设备上需要测试的 UI 应用,观察并等待 UI 界面完全显示出来时,按下手中的秒表器。

**DDMS工具中的LogCat视图分析**：在手机界面上点击被测 UI 应用,眼睛盯着手机界面与 LogCat视图,等待 UI 出现时,按下鼠标。此时,锁定的日志就是界面Activity 弹出的时间。

**高速摄像机加数据挖掘**：利用高速摄像机拍摄 UI 的启动过程,并利用数据挖掘的方式分析时延。

**录屏分帧法**：用摄像头拍摄被测手机屏幕,用自动化工具或是手动操作被测手机应用,结束拍摄,并把视频拷贝到 PC 上,再运用视频解析工具分析画面中的帧数。

![启动延迟测试方法缺点](https://github.com/openthos/research-analysis/blob/master/projects/android-log/image/%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BB%B6.png)

#### 我的思考：
这些方法只能测试出启动的时间，如何衡量是否启动超时？如何分析导致超时的原因并没有解决。
####论文观点：
一个 Acitivity 启动时间是从“Start”开始到“Displayed”显示的过程,并通过 Intent 机制来实现。Start 表示即将开启一个 Activity,待该 Activity 完全出现时,所消耗的时间就是 UI 的启动时间。在 Displayed 这条日志后面紧跟着一个时间值,该值也表示一个 Activty 显示时间,但这个显示时间与整个启动过程有个响应延迟值。响应延迟是因为在启动过程中,应用的主进程执行了其他操作,导致的时间差。

计算一个 UI 时延的方法有两种:一种是忽略响应延迟,直接计算 Displayed后面的显示时间,即为显示耗时。另一种是包含响应延迟,计算 Start Intent 出现的时间到 Displayed 的时间差。后一种计算方法与用户感观是比较一致的时间。

### 2.2 流畅度差
#### 论文观点：
UI 流畅度总体反映了一个 UI 界面在使用过程中是否流畅。理论上,UI 越流畅,则对应的 FPS 越高。对于应用在终端设备上运行时的 FPS 进行采集分析,可以用来检测应用实际运行的流畅度,帮助开发改进应用不流畅的问题,提升产品的用户体验 。

#### 我的思考：
鉴于上周对SM的分析，SM对FPS的分析更符合人的感受。

####论文观点：

**传统的测试方法：**

**GPU 过度绘制检查方法**：UI 上重绘次数越多,意味着运算越多,帧渲染时间越长,进而引起界面卡顿,不流畅。在手机的“设置”菜单中,选择“开发者选项”,打开“显示 GPU 过度重绘”与“强制进行 GPU 渲染”开关。Android 业界内,设定了一个界面流畅度的标准,当 FPS>=60,Jank<=5时,UI 比较流畅;当 FPS>=30,Jank<=7 时,UI 的流畅度可以接受。输入“adb shell”,进入 PC 与手机的交互模式。

**通过 adb 命令中的 dumpsys　SurfaceFlinger 方法获取 Jank 值**：丢帧的原因是在绘制过程中,CPU 突然被最高优先级的进程调用,执行其他操作,错过了绘制时间,就导致了丢帧的情况。Android 业界内,设定了一个界面流畅度的标准,当 FPS>=60,Jank<=5时,UI 比较流畅;当 FPS>=30,Jank<=7 时,UI 的流畅度可以接受。输入“adb shell”,进入 PC 与手机的交互模式。调用 dumpsys SurfaceFlinger --latency-clear,清空帧缓冲信息。调用 dumpsys SurfaceFlinger –latency<layer-name/activity-name>,列出指定 UI 层最近 128 帧的渲染,显示时间戳信息。dumpsys 命令返回的是以纳秒为单位的时间戳。第一行是屏幕的硬件特性刷新周期,当前为 16.72ms。即为 VSYNC(垂直同步刷新)的时间间隔。接下来的每一行,一共 128 行,为每一帧的 3个不同时间点的时间戳,分别记为 A、B、C 列。其中:

A 列表示应用程序开始绘制这一帧的时间戳;

B 列是 SurfaceFlinger 开始进行垂直同步刷新该帧到屏幕上的时间戳;

C 列是指 SurfaceFlinger 完成垂直同步刷新该帧到屏幕的时间戳。

通过在 B 列与 C 列的基础上,比较相邻两次 SurfaceFlinger 开始进行垂直同步刷新该帧到屏幕的时间戳的时间差,若时间差大于 100ms 则,Jank 数加1,统计出 Jank 数。

![jank](https://github.com/openthos/research-analysis/blob/master/projects/android-log/image/128.png)

**利用已经开发成熟的流畅度测试工具GT** 

**改进的测试方法：**

该工具采用的是手动滑动界面,导致采集到的 FPS 值波动比较大。因为每个人滑动的距离、力度、时间间隔不一样,这些因素都会影响到 FPS 的数值。采用自动化的方式滑动 UI 界面,统计对应的 FPS。改进思路:利用 Android 系统自带的工具 MonkeyRunner 编写脚本,实现自动点击 GT 工具,启动 FPS 监听功能,并连续滑动被测 UI 界面,采集对应的 FPS 值,最后,滑动结束后暂停 GT,结束整个 FPS 值的录制。

![流畅度测试方法缺点](https://github.com/openthos/research-analysis/blob/master/projects/android-log/image/%E6%B5%81%E7%95%85%E5%BA%A6.png)

### 2.3 Crash or ANR
####论文观点：
如果一个 UI的内存优化的比较好,占用内存少,则用户的手机不会出现突然卡死或界面崩溃的异常现象。Android 系统为设备上的每个应用程序都设定了一个最高的可用内存阈值,当一个应用的内存超过这个阈值就会产生 OOM(Out Of Memory)错误,即内存泄露问题。其中,不同的设备为应用程序进程设定的阈值不同,可以通过在命令行中,输入“cat　/system/build.prop”获取应用内存阈值。

在默认情况下应用程序的内存阈值由 heapgrowthlimit 取值大小所决定。而在 Android 系统 3.0 以后允许通过在 manifest.xml 文件中添加“android:largeHeap=true”字段使 heapsize 生效。heapgrowthlimit 与 heapsize 的关系就好比学生在食堂打米饭,一般人的饭量不会超过三碗,而个别壮汉吃到了五碗。这里的三碗米饭就是 heapgrowthlimit 的意思,五碗米饭就是 heapsize代表的含义。heapsize 的取值总是大于的 heapgrowthlimit 的值,某些特殊的应用可以超过最大阈值,但最大限度只能到达 heapsize 的值。

在 Android 应用的开发过程中,如果不合理地使用内存,会导致内存泄露的问题,例如,对一张图片重复储存,其次,代码中保留了不再使用的对象引用,引起这些对象占用的内存无法及时被 GC 线程回收,最终导致程序不断地向虚拟机申请新的内存空间而造成 OOM 的风险。引起 Java 层内存问题的另一个重要原因是代码中没有合理地复用原有数据,而是频繁申请新内存。如连续对一个对象创建很多次,但没有使用。这种依靠 GC 机制进行内存回收的方式并不可靠,并且频繁的进行内存申请会导致触发 GC 操作过多增加系统开销,会影响到应用的流畅度,尤其是在低内存场景下会产生 UI 界面无响应的情况。
####我的思考：
ANR是因为什么原因产生的？线程间的异步调用不合理是否会引起ANR的现象？如何线程间的异步调用不合理会引起ANR的现象，采用AppInsight是否可以实现检测和分析？
####论文观点：
内存测试的主要目的是为了检验一个 UI 界面是否出现内存泄露的问题。当一个 UI 应用软件的内存值突然暴增时,则该应用会出现 Crash 或 ANR 异常。

**传统的测试方法：**

**通过 DDMS 工具中的 Heap视图计算内存值**：启动 DDMS 工具, 并在“Window”菜单下的“Show View”中,选择“Heap”视图。在线程窗口中选择被测试的某类应用。挂上监听 heap 的标志(即点击绿色的小桶)。点击右边的“Cause GC”,进行刷新内存值操作。其中,Allocated 代表 UI 已持有的内存值,如果它超过了进程内存阈值,或者突然剧增,而且值不降下来,就可能会产生 OOM。再次点击绿色小桶符号,即解除heap 监控了。需要注意的是,在挂上监控 heap 标志会影响 UI 的流畅度,所以,不建议流畅度和内存测试同一时间进行,或用使用同一台设备测试。

**dumpsys meminfo 命令行**：在命令行窗口中输入“adb shell”。进入 Android 手机中的 Linux 系统环境下,接着键入查看内存的“dumpsys meminfo”命令行,当命令行中 dalvik allocated 的值超出了最大阈值就会出现内存泄露(OOM)的问题。size 表示历史分配的最大值,allocated 指当前占用的内存值,free 是剩余可用的内存。Pss 值,相当于用户在手机设置菜单中看到的进程占用内存大小的值。shared dirty 表示应用进程间共享的用于写操作复制的内存,priv dirty 是进程中不能被直接覆盖的内存,该进程不与其它进程共享。当进程结束,这部分内存马上被释放。native 指应用进程的堆内存,对应的内存映射名字叫“Heap”。

![dumpsys meminfo](https://github.com/openthos/research-analysis/blob/master/projects/android-log/image/dumpsys%20meninfo.png)

**通过 MAT 工具解析抓取内存快照的 dump 文件**：经常用于开发人员调试自己编写的 Android应用,观察内存变化情况。dump 文件是通过 DDMS 中的 Heap 按钮捕获到的内存文件。

**APT、Emmagee**：利用业界已经存在一些已经开发好了的内存测试工具进行测试

## 3. 论文中的其他知识：
### 3.1 Android 应用软件的测试技术
#### Google
Monkey：压力测试

MonkeyRunner：回归测试

UIAutomator：用来做 UI 测试,它可以获取到界面上所有的 View 元素和控件,也可以用来做功能性测试,自动点击界面上的控件元素,也就是相当于测试人员在手工操作一款 UI。

UIAutomatorViewer：对 UI 组件进行分析

#### FaceBook

开源ATC：用于模拟在各种网络环境下,测试 Android 应用软件在使用过程中是否会出现数据丢包、网络延迟、连接中断等等异常问题

#### IBM

RTW8.5：在 PC 端录制脚本实现自动化测试 Android 应用软件的功能

#### 百度

云测试工具MTC：测试平台上聚集了成百上千种类型的设备,用户只需要将自己开发的 Android应用软件上传到该平台上,就可以对应用软件执行相应的兼容性、性能、虚拟场景等方面的测试工作并且测试结果一般会在八个小时以内以报告的形式输出。

#### 腾讯

GT：进行内存、流畅度、流量等方面的测试

#### 网易公司

Emmagee：测试应用软件的内存、 CPU、流量等

在 Android 测试的过程中经常用到的工具有 Robotium、Monkey、CTS、DDMS、MonkeyRunner、UIAutomator [22]

**DDMS**

(Dalvik Debug Monitor Service)是 Android 开发环境中的 Dalvik 虚拟机调试监控服务 [23] 。在 Android 系统环境下,每个应用程序都拥有自己独立的进程,这些进程运行在一个属于自己的虚拟机上。同时,虚拟机为每一个进程提供了唯一的端口号,用于区分和连接调试器进行调试。

**UIAutormator** 是 Google 官方提供的 Android 系统 4.1 以上版本自带的一个UI 测试框架 [25] 。用来做 UI 测试,它可以获取到界面上所有的 View 元素和控件,也可以用来做功能性测试,自动点击界面上的控件元素,也就是相当于测试人员在手工操作一款 UI。测试人员可以在不需要知道 APP 的源代码的情况下就用 UIAutomator 对程序进行 UI 测试,包括点击 UI 界面上的控件按钮、文本框中内容的输入与清除、拖动控件等操作。UIAutormator 测试是权限范围最大的,可以对整个系统做 UI测试,而不仅仅是局限于单个 APP。

### 3.2 UI 测试内容
#### (1)UI 业务功能测试

业务功能测试主要是验证 UI 的功能是否完备,是否符合需求文档所要求的功能点。
####(2)兼容性测试

兼容性测试主要包括:Android 系统版本的兼容 。手机不同厂家系统的支持。不同分辨率与尺寸的支持。网络的兼容性。UI 应用安装卸载是否兼容在手机端直接安装,或是 PC 连接手机后通过第三方应用软件进行安装等等。
####(3)UI 性能测试

在 Android 系统应用的开发过程中,性能测试是保证用户体验效果的有效途径 。UI 的性能测试主要是测试 UI 的启动时间,UI 与 UI 之间切换是否出现卡顿、UI 占用的内存是否会突然暴增等等。除此之外,性能测试还包括 UI 耗电量与流量测试、占用手机设备的 CPU 大小、Crash 率测试等等。
####(4)稳定性测试

稳定性测试又包含持续测试、压力测试、Monkey 测试。持续测试是指对一个 UI 连续进行操作,不受外界条件的影响。例如,在网络良好的情况下,持续点击 UI 上的一个控件按钮,观察是否会出现异常的情况。在网络比较弱的环境下,执行同样的操作,观察 UI 变化。此时,网络突然中断,仍然持续操作,是否有异常情况发生。压力测试,与持续测试比较类似,一般是指对一个功能点执行很多次数的操作,确定 UI 是否能够抵抗住。比较典型的例子就是,在测试一款手机游戏时,要不停的执行按键操作,观察游戏是否出现奔溃或失灵等异常现象。
####(5)界面易用性测试

界面易用性测试主要是指 UI 布局符合 Android 交互规范、用户的习惯、使用快捷方便等特性。同样的,易用性还表示可以用性强、操作简单、完成任务使用时间短等等。
####(6) 接口性测试

一般而言,一个 Android 应用包括客户端(Client)与服务器端(Service)两个方面 [33] 。接口性测试主要是验证 Client 端的数据更新与 Service 端是否一致,即 UI 界面上是否能够根据服务器端实时更新数据。最简单的例子:微信朋友圈中,好友动态信息的更新。如果用户的某位好友发布了一条动态消息,朋友圈会立即提示有好友动态消息。接口性测试发现的异常现象有:Client 端更新时断开了;Client 端更新时 Service 端挂了等等。
####(7)交互性测试

交互性测试主要是指手机端与 PC 之间,应用软件与系统软件之间的交互[34]。通过 USB 线将手机与 PC 端相连接后,是否能够在 PC 端上直接通过应用宝、手机助手等软件将待安装的手机应用包安装至设备端。在执行一个 UI 时,如果中间突然打进一个电话,当前 UI 与电话应用的界面是否能够正确进行交替等等。
####(8)回归测试

在一个应用完成了所有功能、性能、兼容、交互性等测试之后,就预示着第一轮测试基本快结束了。待开发人员将测试人员提交的 Bug 解决之后,就要进行一轮轮的回归验证测试 。回归测试是按照已经设计好的测试用例将所有功能过一遍,它的目的是验证 Bug 的解决情况以及修复的 Bug 是否会影响 UI相关模块的其他功能。
####(9)灰度测试

灰度测试是在 UI 产品发布之前进行的一项有效测试活动。灰度测试是指选择一部分忠实的用户,试用已经开发好的软件产品。通过灰度测试可以及早的收集到用户的反馈意见,从而不断完善应用的功能。同时,由于 Android设备型号比较多,在测试升级安装时,无法覆盖到所有的设备,通过灰度测试可以弥补资源不足的困境。根据选择用户的范围又将灰度测试分为小灰度与大灰度测试。小灰度测试一般是指选择公司内部的员工,如开发人员、运维、产品经理、推广人员,使用已开发好的一款产品,用以及时发现产品中的缺陷。大灰度,不仅仅在公司内部试用产品,而且同时在市面上选择一部分忠实的用户使用即将发布的应用软件。
#### (10)竞品测试

竞品测试主要是指选择同一类型产品进行功能方面与性能方面的对比,从而发现自身产品的不足与需要改进的地方。通过竞品测试可以使一个软件产品不断完善与优化,达到极致的效果。
