代码来自xi wang的[github](https://github.com/xiw/mini-mc)  
同时阅读[他的博客](kqueue.org/blog/2015005/26/mini-mc)对于理解应该会有帮助  
This implementation comes from the paper [Dart: Directed automated random testing](https://wkr.io/public/ref/godefroid2005dart.pdf) directly

# Codes

## python
- 模块``__future__``：
	- 该语句必须是模块或者程序的第一个语句，使用下个版本的语言特性
	- mm中用到的是``print()``
- ``multiprocessing`` & ``Lock``：应该就是一般的锁
- ``# -*- coding: utf-8 -*-``：修改编码模式
- ``zip()``：接受多个序列作为参数，返回一个tuple

## z3
- Use ``setattr`` to reinterpret some data type or method
	- [``BitVec``](http://z3prover.github.io/api/html/namespacez3py.html#a913e9b8f465ac36b8825a785437b33b7): a symbolic 32-bit integer. Need set [``BitVecRef``](http://z3prover.github.io/api/html/classz3py_1_1_bit_vec_ref.html#af32e4a451632afde7f8e9d45146b56cf)'s member function first with ``setattr``.
	- [``BoolRef``](http://z3prover.github.io/api/html/classz3py_1_1_bool_ref.html): Python will convert ``==`` into ``__bool__`` in 3.x or ``__nonzero__``
- [``Solver()``](http://z3prover.github.io/api/html/classz3py_1_1_solver.html): the main function in z3.
	- ``add()``: add constraints into the solver
	- ``check()``: check whether the assertions in the given solver plus the optional assumptions are consistent or not. The return value is ``sat``, ``unsat`` and ``unknow``.
	- ``push()``: set a backtracing point, for later goint back to this condition of constraints.
	- ``model()``: run a model for last ``check()``, get its value of a constraint

# Explanation

## Symbolic
What the code does here is to to through all the branch generated by a judgment as ``if``, forks the process if there are branches and adds the constraint to ``Solver()`` simutaneously. And checks whether these constraints are reachable in the end. The complex mess--check whether the constraints are reachable is handled by z3.

``test_me()``是一个[Dart](https://wkr.io/public/ref/godefroid2005dart.pdf)第二节的一个例子，模拟了一个bug：当``z = x + 10 && z = 2 * x``时，程序``abort``。显然，只有``x = 10``时会遇到这个bug。而随机选取int型的x值只有1/2^32的可能会发现这个bug。论文原文说： 
> The problem is typical of random testing: **it is difficult to generate imput values that will drive the program through all its different execution paths.**

Dart随机选取初始值，运行程序至结束。之后计算最后一个约束的非命题所需要的初始值，迫使程序运行到一个新的路径上。当程序重新开始的时候，会使用这个初始值。而从**Symbolic**程序的运行结果可以发现，z3中的``Solver``可以看到是自顶向下的，遍历所有的分支，遍历结束后求解该分支的约束方程，看是否可以到达。

## Concolic
我在这部分代码中加入了每一步``trace``和``solver``的输出，用来注释和理解。
那么**Concolic**的实现就显而易见了，任取一个初始值运行程序，在一个栈``trace``中记录运行中所有的判断和结果，弹出最后一个结果取非，得到新的路径。程序中的例子改用逻辑语言如下：

```
	//The former trace
	trace := p * q
	//Get the new constraint
	solver := ~trace = -(p * q)
	solver &= -q
	solver &= p
	//Symplify the constraint
	solver := -(p * q) * -q * p
		= (-p + -q) * -q * p
		= -p * -q * p + -q * -q * p
		= p * -q
```
得到新的``solver``作为约束之后（Symbolic），计算满足该约束的值（Concrete），与得到的新约束一同带入程序进行计算（事实上新的约束在下一次运算中作为一个约束）。**不过事实上最有意思的部分，也就是通过约束获得具体值的过程（我猜是线性规划），交给z3来完成了，具体的实现没有去了解。**  
如此，证明这样确实走入了另一个分支，而且通过深度优先遍历不断向上或向下，遍历完所有的分支。同时产生了每种遍历方式的参数值。
