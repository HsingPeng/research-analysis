# 概况
目前Android智能手机飞速发展，但是Android平台的I / O堆栈还远远不够，因为它无法充分利用硬件资源的最大性能。 Android I/O栈主要分为两块具有不同IO特征的分区，即/data和/sdcard分区
+ /data分区
主要用于存储手机平时使用产生的文本文档等文件，此外以电话簿为例的手机内部数据库文件也保存在其中
IO特征为文件较小，且随机写较多
+ /sdcard分区
主要用于存储用户需要的媒体文件，例如音乐、视频等等
IO特征是文件大，且大多为顺序写

在老版本的Android中/data与/sdcard是两个分开的分区，两者使用不同的文件系统，/data中使用EXT4，而/sdcard中使用VFAT；     
经过Android的更新，让/d为了消除EXT4和VFAT之间的不同，在/sdcard和EXT4文件系统的中间加上了一层FUSE，从而让/data和/sdcard都同时使用EXT4文件系统，/sdcard也正式成为了/data目录下的一个子目录。

目前调研中/sdcard部分，通过实现FUSE层的缓冲区，提高FUSE层文件写入的效率，减少原本/sdcard目录下写文件存在的多次用户态与内核态的上下文切换问题，从而提高写入效率。

关于/data部分，实际上问题在于SQLite和EXT4之间交互的差异问题，这个问题导致在Android I/O栈中存在过多的随机写操作，使得效率降低，且由于SQLite和EXT4两者都存在的日志操作，使得较小数据的写入需求也会导致几倍以上的实际数据写入磁盘。

# SQLite及EXT4交互问题详细分析
## SQLite概述
SQLite是遵守ACID的关系数据库管理系统，它包含在一个相对小的C程序库中。与许多其它数据库管理系统不同，SQLite不是一个客户端/服务器结构的数据库引擎，而是被集成在用户程序中。其可能是最广泛部署的数据库引擎。

实际上我理解其就是对文件规范化写的一个工具，即不像以往的文件中全部都是文件内容，而是采取一个对文件中具体内容进行规范化的方式，其在一个文件包含了多个数据库页，在第一个页面包含了数据库头以及数据库结构的信息，之后的数据库文件中，包含了页头、数据索引以及具体的数据等，具体数据库文件的结构如下图所示：
![SQLite_page_structure](https://github.com/openthos/research-analysis/blob/master/developers/%E9%99%B6%E7%90%9B%E5%B5%98/picture/SQLite_page_structure.png)

SQLite遵守ACID原则，即原子性、一致性、隔离性、持久性，而现代数据库基本都基于日志的方式实现ACID，这也是SQLite在EXT4上会产生问题的原因。

## SQLite的日志
SQLite提供了回滚日志（undo logs）和前滚日志（redo logs）的机制。
回滚日志即一个回滚日志文件，其由一个or多个日志段组成，每个日志段包含端头以及很多老的数据库页（undo log）。正常情况下只有一个日志段位于回滚日志文件中，因为当SQLite的一个事物完成后，就会从这个回滚日志中删除undo log。

简单来说，SQLite提供数据库中事务的机制，即一个事务要么完成、要么就不做，因此如果做到一半出现断点等情况就无法处理。因此SQLite中的具体操作是对于一个事务的执行，例如对数据库中的某数据进行修改，首先进行SQLite的日志记录，在回滚日志文件中添加一个日志段，并在这个日志段中记录段头以及要记录的数据页的原本的数据，这里可能会是对要修改的数据页的全部拷贝，之后再进行实际的数据库则的修改工作。如果中间出现问题，那么就会利用undo logs中的旧数据页刷新回数据库页中，完成出现错误就回滚的操作。

具体例子如下：
假如要将原值为1和2的A、B两个变量的值变为3和4，简化过程： 
1. 事务开始 
2. 记录A=1到undo log 
3. 修改A=3 
4. 记录B=2到undo log 
5. 修改B=4 
6. 将undo log 写入到磁盘中 
7. 将数据写到磁盘 
8. 事务提交 

其中所有的数据修改都是在内存中的，之后将内存中的数据写入到磁盘中。
对于undo log的作用，如果在7、8两步之间系统断电，由于undo log已经在磁盘中了，因此可以用来回滚事务。
如果在1-6之间断电，那么因为数据没有持久化到磁盘，因此磁盘还是保持事务开始前的状态。

另外还有redo log的操作，作用与undo log相反，记录的是修改后的数据，也会在数据库页的正式修改前记录到磁盘上，从而不需要具体去修改具体的数据库页，而是直接将redo logs刷新到数据库中即可。

## EXT4文件系统的日志功能
>日志文件系统是一个具有故障恢复能力的文件系统，在这个文件系统中，因为对目录以及位图的更新信息总是在原始的磁盘日志被更新之前写到磁盘上的一个连续的日志上，所以它保证了数据的完整性。当发生系统错误时，一个全日志文件系统将会保证磁盘上的数据恢复到发生系统崩溃前的状态。同时，它还将覆盖未保存的数据，并将其存在如果计算机没有崩溃的话这些数据可能已经遗失的位置，这是对关键业务应用来说的一个很重要的特性。

实际上，如果系统采用传统的未提供日志功能的文件系统，那么OS在检测到系统非正常关机的时候，就会通过fsck执行一致性检查，其会扫描整个文件系统，并修复任何能够安全修复的问题，如果文件系统很大，那么就会花费大量的时间。这时候日志文件系统维护的一份日志就体现了作用，日志会在一个循环的缓冲区内记录文件系统的修改，之后定期将其提交到文件系统中。一旦文件系统发生崩溃，那么日志文件就会起到一个checkpoint的作用，可以恢复未保存的文件，防止损坏文件系统元数据

![日志文件系统结构](https://github.com/openthos/research-analysis/blob/master/developers/%E9%99%B6%E7%90%9B%E5%B5%98/picture/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png)

在EXT4文件系统中，会在磁盘上保留一段小的连续区域（默认是128MB），作为尽可能需要快速写入磁盘的重要数据的存放地，这就是日志的存储区域，如下图所示

![日志存储区域结构](https://github.com/openthos/research-analysis/blob/master/developers/%E9%99%B6%E7%90%9B%E5%B5%98/picture/%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BB%93%E6%9E%84.png)

日志文件在文件系统中是普通文件，但是是隐藏的。

EXT4中使用JBD2（Journaling block device 2）进行日志的记录，其作用就是在EXT4文件系统把数据提交到驱动前先调用它，它会根据系统不同的设置完成数据或是操作的备份，之后再让EXT4提交数据，而文件系统吧数据写入设备后，就通过JBD2将刚才的数据或者操作备份删除，保证数据的一致性。
如果开启了EXT4的日志功能，那么在/proc/fs下是能够看到存在jbd2这个目录，这是EXT4文件系统在注册的时候就会调用JBD2的函数生成的，目录下根据具体的分区情况分成了几个目录，目录下存在info文件，记录了事务数量等日志的统计信息。

## SQLite与EXT4的交互差异
简单来说，由于SQLite本身具有日志的功能，但是其记录日志的日志记录文件在EXT4看来仍然是一个普通文件，因此EXT4的日志功能对SQLite的日志文件的修改也会进行日志操作。
那么对于我们要对SQLite中一个简单的数据修改，大致流程如下：
1. SQLite进行日志的记录，并提交到磁盘，但是在此之前EXT4通过JBD2首先进行SQLite日志文件的修改的日志记录，具体记录到磁盘的保留区域中，用户不可见
2. SQLite日志文件的修改提交到磁盘上，数据位于分区之中，用户可见
3. SQLite完成日志记录，因此将具体数据提交到磁盘上，EXT4继续进行日志记录，记录到用户不可见的保留区域
4. SQLite具体数据库中的数据修改写到磁盘上，完成数据库中数据的修改

以上的过程可以看到只是一次简单的修改数据库中的某个数据，却产生了三次日志功能的记录工作，具体来说对于对数据库进行10字节的插入工作，但是最后写入到磁盘上的数据会高达30KB以上。这也是因为ext4文件系统通过重量级的fsync()来记录SQLite的日志活动导致。

因此Android IO栈的存储性能不佳，并且这样的问题在使用SSD的手机上尤为严重，因为SSD的擦除、写入的次数是有限的，这样的消耗使得手机的SSD寿命减少。

# 解决思路
目前找到了一篇解决这个问题的论文，其修改SQLite，在其中利用B树的结构，并在其上进行了一些优化，使得SQLite进行数据库的写入操作中，有效减少了fsync()的调用数量并且减少了一个fsync()中的赃页数量，从而达到性能提升的功能。

但是这篇我认为主要是对SQLite的修改，对于EXT4层面并没有进行创新，因此思索是否能在这个方面进行创新，达到提升性能的目的。

本周一的会议中，陈渝老师建议比较F2FS与EXT4文件系统的差别，找出F2FS相比EXT4更适合智能手机的原因，进一步进行测试得出结果，尝试将F2FS的优点添加到EXT4中。
