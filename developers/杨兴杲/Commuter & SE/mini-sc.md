# Codes

## python
- 模块``__future__``：
	- 该语句必须是模块或者程序的第一个语句，使用下个版本的语言特性
	- mm中用到的是``print()``
- ``multiprocessing`` & ``Lock``：应该就是一般的锁
- ``# -*- coding: utf-8 -*-``：修改编码模式

## z3
- Use ``setattr`` to reinterpret some data type or method
	- [``BitVec``](http://z3prover.github.io/api/html/namespacez3py.html#a913e9b8f465ac36b8825a785437b33b7): a symbolic 32-bit integer. Need set [``BitVecRef``](http://z3prover.github.io/api/html/classz3py_1_1_bit_vec_ref.html#af32e4a451632afde7f8e9d45146b56cf)'s member function first with ``setattr``.
	- [``BoolRef``](http://z3prover.github.io/api/html/classz3py_1_1_bool_ref.html): Python will convert ``==`` into ``__bool__`` in 3.x or ``__nonzero__``
- [``Solver()``](http://z3prover.github.io/api/html/classz3py_1_1_solver.html): the main function in z3.
	- ``add()``: add constraints into the solver
	- ``check()``: check whether the assertions in the given solver plus the optional assumptions are consistent or not. The return value is ``sat``, ``unsat`` and ``unknow``.

# Explanation

## Symbolic
What the code does here is to to through all the branch generated by a judgment as ``if``, forks the process if there are branches and adds the constraint to ``Solver()`` simutaneously. And checks whether these constraints are reachable in the end. The complex mess--check whether the constraints are reachable is handled by z3.

## Concolic