# 2017.02.25~2017.03.02

## 1 本周目标：

上周与陈渝老师进行远程会议后，定下本周计划是做一个简单的例子，如下：

尝试在Linux中运行一个简单的Service（如：只有简单的计算功能），然后在Android中的APP可以调用该Service。

第一步：了解 Binder 如何启动新的Service

第二步：了解如何在 Binder 中注册新的Service

第三步：移植相关代码测试

如果这个例子不能够简单的完成，则说明本课题不是我想象中的那么简单，是有研究价值的。

## 2 本周结果：
参考：https://github.com/openthos/research-analysis/blob/master/projects/and-linux/log.md
通过发现上图 1 Socket 过程，看到ActivityManagerService启动Service是通过Socket的方式连接Zygote进程，让它来fork出新的进程，然后ClassLoader.loadClass，之后ActivityManagerService通过Binder与新进程交互，完成启动。
所以Service的运行并不是像我之前想象的一样：是一个进程fork之后，自己通过Binder连接系统服务完成初始化。Service的整个初始化过程受到Zygote控制，它并没有一个main函数主动执行所有逻辑，全是被调用。
我之前完全没有意识到这个概念，太天真了。并且Android系统中的程序在ART虚拟机中运行，这就造成谁来启动Service的问题：

1. Android中的Service在ART虚拟机中运行，而我在Linux中不能这样干，因为我要和Linux中的程序结合，必然要在Linux中启动，比如：Linux中的JAVA程序在JVM中运行。

2. 需要一个服务程序主动调用Service中的函数，完成Service的生命周期。

所以现在将android.jar（APP层依赖库）复制过来，在Linux中编译程序

javac -Djava.ext.dirs=. com/example/bboxh/testipcapplication/MyService.java

虽然能够编译，但是没有程序能够调用。。。

## 3 下周计划：

搞懂ActivityManagerService服务运行的详细过程，然后研究一个调用方案，实现在Linux中启动该Service，并且能够与Android中的ActivityManagerService服务相交互。

目前想到这里面有一些细节有待解决：

1. Linux中的Service的注册问题

2. Linux中的Service的生命周期同步问题
 
 >> chy 很详细，做的不错！

# 2017.02.18~2017.02.24
## 假期至本周工作进展


- 本周工作计划点1:
   - 重现 https://github.com/hungys/binder-for-linux 的操作，在Linux上启动Binder
- 完成情况：
   - 可以运行
- 论文阅读进展：
   - 了解已发表Binder有关的论文研究
- 完成情况：
   - 阅读了三篇论文
   
- 课题实践进展：
  - 无

## 下周计划：
  - 尝试在Linux中运行一个简单的Service（如：只有简单的计算功能），然后在Android中的APP可以调用该Service。
    - 第一步：了解 Binder 如何启动新的Service
    - 第二步：了解如何在 Binder 中注册新的Service
    - 第三步：移植相关代码测试
