#进度
1.了解了nop追踪器下sched事件产生追踪记录的参数意义  
2.在openthos上可以运行latencytop和ftrace  
3.设想了一些人为bug，准备模拟一些bug  
4.解析了部分追踪数据，目前对这些数据还没做到彻底了解  

#几种类型bug模拟
##1.运行时间过长的bug模拟
```c
#include<stdio.h>
int main(){
 long long time=10000000000;
 printf("program start...");
 while(time--) {}
 printf("program end...");
 return 0;
}
```

##2.sleep时间过长的bug模拟
```c
#include<stdio.h>
#include<unistd.h>
int main(){
 printf("program start...");
 sleep(10);
 printf("program end...");
 return 0;
}
```

#相关问题
##1.时间戳不匹配问题
在ftrace中采用的时间戳和打印log的时间戳并不匹配，ftrace中提供了多种时间戳方案，但目前没有找到与系统时间戳相匹配方案
##2.ftrace自身时间误差问题
```
    longTime_bug-5735  [002] dN..  3911.816235: sched_stat_runtime: comm=longTime_bug pid=5735 runtime=6009 [ns] vruntime=314745187544 [ns]
    longTime_bug-5735  [002] dN..  3911.816236: sched_stat_wait: comm=rcu_sched pid=7 delay=0 [ns]
```
从时间戳上看一个时间戳是3911.816235,一个时间戳是3911.816236,这两个时间戳相见应该是在1us？但是此时的runtime却显示到了6us左右(vruntime不必考虑，为cfs调度算法中虚拟运行时间，作为红黑树中的键值)  
这两者之间的误差很大，这里是对时间戳的理解问题吗?(或者对runtime自己的不理解)
##3.ftrace可以追踪到某个进程相对完整的生命周期吗？
在追踪过程中，可以通过设置buffer_size大小使得缓冲区可以容纳更多的进程信息，但是由于产生的无用信息太多，还是不能确定一个进程完全的被ftrace记录下其轨迹  
另外在使用ftrace追踪下列一段代码时,遇到了一个问题:   
```
#include<stdio.h>
int main(){
 int input=0;
 printf("program start...\n"); 
 scanf("%d",&input);
 printf("input is %d\n",input);
 printf("program end...\n");
 return 0;
}
```
在追踪该段代码时,如果不输入任何整数，让程序阻塞在原处（原本想通过该程序模拟io阻塞的，期待出现iowait状态，可能想错？），意外的发现在ftrace中并不能发现该进程的踪迹。但是通过ps -all命令是可以发现该进程的，该进程处于T状态(是否处于T状态下的进程都无法被追踪?)。输入整数后，该进程是可以被追踪到的。那追踪到的信息是完全的吗（直观上不是）？
目前的两个主要问题是：第一ftrace记录的信息是否是全的，第二关于进程的起始与结束两个关键点确定.
##4.ftrace了解不够
ftrace功能比较强大，目前来说我们主要运用的events下的sched相关事件，实际上ftrace在关于调度追踪方面的能力还有很多,类似与proc,ftrace也是性能分析一种思路，有必要进一步了解ftrace其他相关功能。
##5.bug模拟
将分析运用到实际是我们最终的目标，但在开始的时候我们可以人为模拟bug，如果人为模拟的bug都无法通过我们的分析发现，那么实际问题也将很难发现。可以通过while循环，sleep调用这种模拟一些性能bug，但这些bug过于简单，模拟一些复杂bug是十分重要的（比如多线程的一类的bug）。收集模拟一些bug是对以后的性能分析也是有必要的。
